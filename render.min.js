
const electron = require("electron");
// const ipcRender = electron.ipcRenderer;
// const dotenv = require('dotenv');
const ethers = require('ethers');
const ipcRenderer = electron.ipcRenderer;
const fs = require("fs");
const os = require("os");
const path = require("path");
const fetch = require("cross-fetch");

var stopScript;
var botStarted;
var savePath;
var envFilePath;
var readEnvVars;

envFilePath = path.resolve(__dirname, ".env");
readEnvVars = () => fs.readFileSync(envFilePath, "utf-8").split(os.EOL);

ipcRenderer.on('LoadConfig', (event, data) => {
    savePath=String(data);
    envFilePath = path.resolve(savePath, ".env");
    readEnvVars = () => fs.readFileSync(envFilePath, "utf-8").split(os.EOL)
    readValues();
});

const getEnvValue = (key) => {
  // find the line that contains the key (exact match)
  const matchedLine = readEnvVars().find((line) => line.split("=")[0] === key);
  // split the line (delimiter is '=') and return the item at index 2
  return matchedLine !== undefined ? matchedLine.split("=")[1] : null;
};

const setEnvValue = (key, value) => {
  const envVars = readEnvVars();
  const targetLine = envVars.find((line) => line.split("=")[0] === key);
  if (targetLine !== undefined) {
    // update existing line
    const targetLineIndex = envVars.indexOf(targetLine);
    // replace the key/value with the new value
    envVars.splice(targetLineIndex, 1, `${key}=${value}`);
  } else {
    // create new key value
    envVars.push(`${key}=${value}`);
  }
  // write everything back to the file system
  fs.writeFileSync(envFilePath, envVars.join(os.EOL));
};

var Formatter = (function () {
  var me = {};

  me.percentage = function (val, places) {
      if (typeof places == 'undefined')
          places = 1;

      var v;
      if (typeof val == 'function')
          v = val()
      else
          v = val;

      if (isNaN(v) || v == null || v == 'Infinity')
          v = '';
      else
          v = Number(v * 100).toFixed(places) + "%";

      return v;
  };

  me.decimal = function (val) {
      if (typeof val == 'undefined')
          return '';

      var v;
      if (typeof val == 'function')
          v = val()
      else
          v = val;

      if (typeof v != 'undefined')
          v = v.replace(/[^0-9\.]/gi, '');
      
      if (v.length < 1)
          return '';

      return Number(v) * 0.01;
  };

  return me;
}());

function msgBox(options) {
  ipcRenderer.send(
    "ShowMessageBox",
    options
    )
}

function stopBot() {

    stopScript = 1;
  
    if (botStarted == 1) {
    msgBox({
        title: 'BlockChain Sniper Bot', 
        // buttons: ["OK", "Cancel"], 
        icon: __dirname + '/images/icon.ico',
        message: 'Sniper Bot Stopped!', 
        detail: 'BlockChain Sniper Bot stopped manually!'})
    }
    else {
        console.log("grey: Blockchain Sniper Bot is not running!")
    }
};

function startBot() {

  if (botStarted == 1) {
    console.log("<br />")
    console.log("\n Bot is already running...");
    console.log("<br />")
    return;
  }
  else{

    stopScript = 0;
    botStarted = 1;
    var data;
    var wss;

    var selectbox = document.getElementById("Blockchain")
    var selected = selectbox.options[selectbox.selectedIndex].text;

    selectbox.setAttribute("disabled","disabled");

    if (selected == "BSC Testnet") {
      // console.log(selected)
      var data = {
      
        // WBNB: '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', //wbnb testnet
        WBNB: getEnvValue('WBNB_TESTNET'), 
        
        // to_PURCHASE: '0xe9e7cea3dedca5984780bafc599bd69add087d56',  //token that you will purchase = BUSD for test '0xe9e7cea3dedca5984780bafc599bd69add087d56' 
        to_PURCHASE: getEnvValue('to_PURCHASE'), 
      
        AMOUNT_OF_WBNB : getEnvValue('AMOUNT_WBNB'), // how much you want to buy in WBNB
      
        // factory: '0xB7926C0430Afb07AA7DEfDE6DA862aE0Bde767bc', // pcs factory bsc testnet
        factory: getEnvValue('FACTORY_TESTNET'),
      
      
        // router: '0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3', // pcs router bsc testnet
        router: getEnvValue('ROUTER_TESTNET'),
      
        recipient: getEnvValue('YOUR_ADDRESS'), //your wallet address,
      
        Slippage : getEnvValue('SLIPPAGE'), //in Percentage
      
        sellSlippage : getEnvValue('SELL_SLIPPAGE'), //Sell Slippage
        
        gasPrice : getEnvValue('GWEI'), //in gwei
        
        gasLimit : getEnvValue('GAS_LIMIT'), //at least 21000
      
        minBnb : getEnvValue('MIN_LIQUIDITY_ADDED') //min liquidity added
      }
      var wss = 'wss://speedy-nodes-nyc.moralis.io/61287d34e3ef0722a2d8ce89/bsc/testnet/ws'; //BSC TESTNET MORALIS
      // var wss = 'wss://data-seed-prebsc-2-s1.binance.org:8545'; //BSC TESTNET
    }

    if (selected == "BSC Mainnet") {
      // console.log("Mainnet")
      
      var data = {
        // WBNB: process.env.WBNB_CONTRACT, //wbnb
      
        // WBNB: '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', //wbnb testnet
        WBNB: getEnvValue('WBNB_CONTRACT'), //wbnb testnet
        
        // to_PURCHASE: '0xe9e7cea3dedca5984780bafc599bd69add087d56',  //token that you will purchase = BUSD for test '0xe9e7cea3dedca5984780bafc599bd69add087d56' 
        to_PURCHASE: getEnvValue('to_PURCHASE'), //Testnet BUSD Address
      
        AMOUNT_OF_WBNB : getEnvValue('AMOUNT_WBNB'), // how much you want to buy in WBNB
      
        // factory: process.env.FACTORY,  //PancakeSwap V2 factory
        // factory: '0xB7926C0430Afb07AA7DEfDE6DA862aE0Bde767bc', // pcs factory bsc testnet
        factory: getEnvValue('FACTORY'),
      
        // router: process.env.ROUTER, //PancakeSwap V2 router
      
        // router: '0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3', // pcs router bsc testnet
        router: getEnvValue('ROUTER'),
      
        recipient: getEnvValue('YOUR_ADDRESS'), //your wallet address,
      
        Slippage : getEnvValue('SLIPPAGE'), //in Percentage
      
        sellSlippage : getEnvValue('SELL_SLIPPAGE'), //Sell Slippage
        
        gasPrice : getEnvValue('GWEI'), //in gwei
        
        gasLimit : getEnvValue('GAS_LIMIT'), //at least 21000
      
        minBnb : getEnvValue('MIN_LIQUIDITY_ADDED') //min liquidity added
      }
      var wss = 'wss://speedy-nodes-nyc.moralis.io/61287d34e3ef0722a2d8ce89/bsc/mainnet/ws'; //BSC MAINNET MORALIS
      // var wss = 'wss://bsc-ws-node.nariox.org:443'; //BSC MAINNET
    }
   
    if(getEnvValue('WBNB_TESTNET') == "" || getEnvValue('to_PURCHASE') == "" || getEnvValue('AMOUNT_WBNB') == "" || getEnvValue('FACTORY_TESTNET') == ""
        || getEnvValue('ROUTER_TESTNET') == "" || getEnvValue('YOUR_ADDRESS') == "" || getEnvValue('SLIPPAGE') == "" || getEnvValue('SELL_SLIPPAGE') == ""
        || getEnvValue('GWEI') == "" || getEnvValue('GAS_LIMIT') == "" || getEnvValue('MIN_LIQUIDITY_ADDED') == "" || getEnvValue('YOUR_MNEMONIC') == "" 
        || getEnvValue('WBNB_TESTNET') <= 0 || getEnvValue('to_PURCHASE') <= 0 || getEnvValue('AMOUNT_WBNB') <= 0 || getEnvValue('FACTORY_TESTNET') <= 0
        || getEnvValue('ROUTER_TESTNET') <= 0 || getEnvValue('YOUR_ADDRESS') <= 0 || getEnvValue('SLIPPAGE') <= 0 || getEnvValue('SELL_SLIPPAGE') <= 0
        || getEnvValue('GWEI') <= 0 || getEnvValue('GAS_LIMIT') <= 0 || getEnvValue('MIN_LIQUIDITY_ADDED') <= 0 || getEnvValue('YOUR_MNEMONIC') <= 0) {
            msgBox({
                title: 'BlockChain Sniper Bot', 
                // buttons: ["OK", "Cancel"], 
                icon: __dirname + '/images/icon.ico',
                message: 'Unconfigured parameters!', 
                detail: 'Please configure all the parameters!'});

                console.log("grey: Please configure all the parameters! Parameters with value 0 are not accepted!");
                console.log("<br />");
                stopScript = 1;
                botStarted = 0;
                selectbox.removeAttribute("disabled");
                
                return;
        }

    let initialLiquidityDetected = false;
    let jmlBnb = 0;
    let cBuy = 0;
  
    let buys = 0;
    let buysCounter = 1;
    let sellProfit = getEnvValue('TARGET_PROFIT');
  
    const bscMainnetUrl = 'https://bsc-dataseed1.defibit.io/'; //https://bsc-dataseed1.defibit.io/'; //https://bsc-dataseed1.defibit.io/ https://bsc-dataseed.binance.org/
    // const wss = 'wss://apis.ankr.com/wss/307403d3a9cf466ca19d6fbbb76e92ee/f9462031a148219cfc0be97839a68f3f/binance/full/main'; //'wss://bsc-ws-node.nariox.org:443';
    // const wss = 'wss://data-seed-prebsc-2-s1.binance.org:8545'; //BSC TESTNET
    const mnemonic = getEnvValue('YOUR_MNEMONIC'); //your memonic;
    const tokenIn = data.WBNB;
    const tokenOut = data.to_PURCHASE;
    // const provider = new ethers.providers.JsonRpcProvider(bscMainnetUrl)
    const provider = new ethers.providers.WebSocketProvider(wss);
    const wallet = new ethers.Wallet(mnemonic);
    const account = wallet.connect(provider);
  
    const factory = new ethers.Contract(
      data.factory,
      [
        'event PairCreated(address indexed token0, address indexed token1, address pair, uint)',
        'function getPair(address tokenA, address tokenB) external view returns (address pair)'
      ],
      account
    );
  
    const router = new ethers.Contract(
      data.router,
      [
        'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)',
        'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
        'function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
        'function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable'
      ],
      account
    );
  
    const erc = new ethers.Contract(
      data.WBNB,
      [
        {"constant": true,"inputs": [{"name": "_owner","type": "address"}],"name": "balanceOf","outputs": [{"name": "balance","type": "uint256"}],"payable": false,"type": "function"},
        {"constant": false,"inputs":[{"name": "spender","type": "address"},{"name":"amount","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},
        {"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}
      ],
      account
    );  
  
    const tknContract = new ethers.Contract(
      data.to_PURCHASE,
      [
        {"constant": true,"inputs": [{"name": "_owner","type": "address"}],"name": "balanceOf","outputs": [{"name": "balance","type": "uint256"}],"payable": false,"type": "function"},
        {"constant": false,"inputs":[{"name": "spender","type": "address"},{"name":"amount","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},
        {"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},
        {"inputs":[{
                "internalType":"uint256",
                "name":"amountIn",
                "type":"uint256"
            },
            {
                "internalType":"uint256",
                "name":"amountOutMin",
                "type":"uint256"
            },
            {
                "internalType":"address[]",
                "name":"path",
                "type":"address[]"
            },
            {
                "internalType":"address",
                "name":"to",
                "type":"address"
            },
            {
                "internalType":"uint256",
                "name":"deadline",
                "type":"uint256"
            }
          ],
          "name":"swapExactTokensForETHSupportingFeeOnTransferTokens",
          "outputs":[
            
          ],
          "stateMutability":"nonpayable",
          "type":"function"
      }
      ],
      account
    );

    const run = async () => {
    try{
      await verifyStop();
      await checkLiq();
      
    }
    catch {
        if (e == "Controlled error !") {
            return;
          }
          else {
            console.log("<br />")
            console.log("red: Caught error " )
            console.log("<br />")
            console.log("red: " + e)
            console.log("<br />")
            stopScript = 1;
            botStarted = 0;
            selectbox.removeAttribute("disabled");

            return;
          }
    }
    }
      
    let checkLiq = async() => {
    try{
      await verifyStop();
      const pairAddressx = await factory.getPair(tokenIn, tokenOut);
      console.log((`aqua: pairAddress: ${pairAddressx}`));
      if (pairAddressx !== null && pairAddressx !== undefined) {
        // console.log("pairAddress.toString().indexOf('0x0000000000000')", pairAddress.toString().indexOf('0x0000000000000'));
        if (pairAddressx.toString().indexOf('0x0000000000000') > -1) {
          await verifyStop();
            console.log((`red: pairAddress ${pairAddressx} not detected. Auto restart`));
            await new Promise(r => setTimeout(r, 1000));
            return await run();
          } 
        }
      const pairBNBvalue = await erc.balanceOf(pairAddressx); 
      jmlBnb = ethers.utils.formatEther(pairBNBvalue);
      console.log(`aqua: value BNB : ${jmlBnb}`);
    
      if(jmlBnb > data.minBnb){
        await verifyStop();
        await buyAction();
      }
      else{
        await verifyStop();
          initialLiquidityDetected = false;
          console.log('aqua: Run again...');
          return await run();
        }
        }
        catch(e) {
            if (e == "Controlled error !") {
                // console.log(e +  "  canceling script")
                return;
              }
              else {
                console.log("<br />")
                console.log("red: Caught error " )
                console.log("<br />")
                console.log("red: " + e)
                console.log("<br />")
                stopScript = 1;
                botStarted = 0;
                selectbox.removeAttribute("disabled");
                // await verifyStop();
                return;
              }
        }
    };
  
    let buyAction = async() => {
        try{
      await verifyStop();
      if(initialLiquidityDetected === true) {
        console.log("<br />")
        console.log('grey: The token has already been purchased!');
        console.log("<br />")
        botStarted = 0;
        return null;
      }
  
      // Check if wbnb is aproved to be spent
      const checkAllowWBNB = await erc.allowance(data.recipient, data.router);
      if (String(checkAllowWBNB) < data.AMOUNT_OF_WBNB) {
        //Aprove WBNB to be spend
        console.log("<br />");
        console.log("info: Aprove WBNB to be spent");
        const approveWBNB = await erc.approve(data.router, ethers.constants.MaxUint256);
        const rec = await approveWBNB.wait();
        console.log("<br />");
        console.log("blue: WBNB approved to be spent");
      }
      else {
        console.log("<br />");
        console.log("blue: WBNB Already approved to be spent");
      };

      
      initialLiquidityDetected = true;
     //We buy x amount of the new token for our wbnb
     const amountIn = ethers.utils.parseUnits(`${data.AMOUNT_OF_WBNB}`, 'ether');
     const amounts = await router.getAmountsOut(amountIn, [tokenIn, tokenOut]);
    
    
     //Our execution price will be a bit different, we need some flexbility
     const amountOutMin = amounts[1].sub(amounts[1].div(`${data.Slippage}`)); 
  
    //  console.log("bckGreen: Start to buy");
    console.log("<br />");
     console.log("info: Buying Token...");
     console.log("info: ====================================================================");
     console.log(`yellow: tokenIn: ${ethers.utils.formatEther(amountIn)} ${tokenIn} (WBNB)`)
     console.log(`yellow: tokenOut: ${ethers.utils.formatEther(amountOutMin.toString())} ${tokenOut}`)
    
    console.log("<br />");
     console.log('info: Processing Transaction...');
     console.log("info: ====================================================================");
     console.log((`yellow: amountIn: ${ethers.utils.formatEther(amountIn)}`));
     console.log((`yellow: amountOutMin: ${amountOutMin}`));
     console.log((`yellow: tokenIn: ${tokenIn}`));
     console.log((`yellow: tokenOut: ${tokenOut}`));
     console.log((`yellow: data.recipient: ${data.recipient}`));
     console.log((`yellow: data.gasLimit: ${data.gasLimit}`));
     console.log((`yellow: data.gasPrice: ${ethers.utils.parseUnits(`${data.gasPrice}`, 'gwei')}`));
     console.log("<br />")
  
     cBuy = cBuy + 1;
    
       const tx = await router.swapExactTokensForTokens(
       amountIn,
       '0',
       [tokenIn, tokenOut],
       data.recipient,
       Date.now() + 1000 * 60 * 5, //10 minutes
       {
         'nonce': provider.getTransactionCount(data.recipient),
         'gasLimit': data.gasLimit,
         'gasPrice': ethers.utils.parseUnits(`${data.gasPrice}`, 'gwei')
      });
  
    
    
        const receipt = await tx.wait(); 
        console.log(`aqua: Transaction receipt : https://www.bscscan.com/tx/${receipt.logs[1].transactionHash}`);
        console.log("<br />")
        buys = buys +1;
        if (buys >= buysCounter) {
          await verifyStop();
          await calcProfit();
        }
        else {
          await verifyStop();
          cBuy = cBuy - 1;
          initialLiquidityDetected = false;
          console.log(("grey: Processing another buy..."));
          await buyAction();
        }
    }
    catch(e) {
        if (e == "Controlled error !") {
            return;
          }
          else {
            console.log("<br />")
            console.log("red: Caught error " )
            console.log("<br />")
            console.log("red: " + e)
            console.log("<br />")
            stopScript = 1;
            botStarted = 0;
            selectbox.removeAttribute("disabled");
            
            return;
          }
    }
    }
  
    let calcProfit = async() => {
        try{
        await verifyStop();
        const tokenBalance = await tknContract.balanceOf(data.recipient);
        const tokenBal = ethers.utils.formatEther(tokenBalance);
    
        const tokenAmounts = await router.getAmountsOut(tokenBalance, [tokenOut, tokenIn]);
        const tokenAmount = ethers.utils.formatEther(tokenAmounts[1]);
    
        const profit = ((tokenAmount - data.AMOUNT_OF_WBNB)/data.AMOUNT_OF_WBNB) * 100;
        const amountProfit = (tokenAmount - data.AMOUNT_OF_WBNB);
    
        console.log("<br />")
        console.log('info: Calculating profit...');
        console.log('info: ====================================================================');
        console.log((`yellow: tokensBought: ${tokenBal}`));
        console.log((`yellow: tokenAmountBNB: ${tokenAmount}`));
        console.log((`yellow: bnbSpent: ${data.AMOUNT_OF_WBNB} BNB`));
    
    
        if (data.AMOUNT_OF_WBNB < tokenAmount) {
          console.log(("bckGreen: Your profit: ") + (Math.round(profit * 100) / 100)  + (" %"));
          console.log(("bckGreen: You win: ") + (Math.round(amountProfit * 100) / 100)  + (" BNB"));
          console.log("<br />")

          if(parseFloat(tokenAmount) > (parseFloat(data.AMOUNT_OF_WBNB)*(1+parseFloat(sellProfit))*buysCounter)) {
            await verifyStop();
            await sellAction();
          }
          else {
            await new Promise(r => setTimeout(r, 5000));
            await verifyStop();
            await calcProfit();
          }
        }
        else {
          console.log(("bckRed: Your profit: ") + (Math.round(profit * 100) / 100)  + (" %"));
          console.log(("bckRed: You lose: ") + (Math.round(amountProfit * 100) / 100)  + (" BNB"));
          console.log("<br />")

          await new Promise(r => setTimeout(r, 5000));
          await verifyStop();
          await calcProfit();
      }
    }
    catch(e) {
        if (e == "Controlled error !") {
            return;
          }
          else {
            console.log("<br />")
            console.log("red: Caught error " )
            console.log("<br />")
            console.log("red: " + e)
            console.log("<br />")
            stopScript = 1;
            botStarted = 0;
            selectbox.removeAttribute("disabled");
            return;
          }
    }
    };
  
    let sellAction = async() => {
    try{
      await verifyStop();
      const tokenBalance = await tknContract.balanceOf(data.recipient);
  
      if (tokenBalance == 0) {
        console.log(("info: Restarting sell action"));
        console.log("<br />")
        await new Promise(r => setTimeout(r, 1000));
        await verifyStop();
        await sellAction();
      }
      else {

      const tokenBal = ethers.utils.formatEther(tokenBalance);

      const tokenAmounts = await router.getAmountsOut(tokenBalance, [tokenOut, tokenIn]);
      const tokenAmount = ethers.utils.formatEther(tokenAmounts[1]);
    
  
      // Check if token is aproved to be spent
      const checkAllowToken = await tknContract.allowance(data.recipient, data.router);
      if (+ethers.utils.formatEther(String(checkAllowToken)) < +tokenBalance) {
        //Aprove token to be spent
        console.log("<br />");
        console.log("info: Approve Token to be spent");
        await verifyStop();
        const tokenApprove = await tknContract.approve(data.router, ethers.constants.MaxUint256);
        const recApprove = await tokenApprove.wait();
        console.log("<br />");
        console.log(("blue: Token Approved to be spent"));
        console.log("<br />")
      }
      else {
        console.log("<br />");
        console.log("blue: Token Already Approved to be spent");
        console.log("<br />");
      };
   
      const tokenAmountMin = tokenAmounts[1].sub(tokenAmounts[1].div(`${data.sellSlippage}`)); 

      console.log("info: Selling Token...");
      console.log('info: ====================================================================');
      console.log(`yellow: tokenIn: ${ethers.utils.formatEther(tokenBalance)} ${tokenOut}`);
      console.log(`yellow: tokenOut: ${tokenAmountMin.toString()} ${tokenIn} (WBNB)`);
      console.log("<br />")
    
    
     console.log('info: Processing Transaction.....');
     console.log('info: ====================================================================');
     console.log((`yellow: amountOutMin: ${tokenAmountMin}`));
     console.log((`yellow: tokenIn: ${tokenOut}`));
     console.log((`yellow: tokenOut: ${tokenIn}`));
     console.log((`yellow: data.recipient: ${data.recipient}`));
     console.log((`yellow: data.gasLimit: ${data.gasLimit}`));
     console.log((`yellow: data.gasPrice: ${ethers.utils.parseUnits(`${data.gasPrice}`, 'gwei')}`));
    
     await verifyStop();
     const tx = await router.swapExactTokensForTokens(
       tokenBalance,
       tokenAmountMin,
       [tokenOut, tokenIn],
       data.recipient,
       Date.now() + 1000 * 60 * 10, //10 minutes
       {
         'gasLimit': data.gasLimit,
         'gasPrice': ethers.utils.parseUnits('20', 'gwei')
     }
     );
    
     await verifyStop();
        const receipt2 = await tx.wait();
        console.log("<br />")
        console.log(`aqua: Transaction receipt : https://www.bscscan.com/tx/${receipt2.logs[1].transactionHash}`);
        console.log("<br />")
        console.log('grey: The bot has ended, congratulations on the profit made!');
        console.log("<br />")
        botStarted = 0;
        selectbox.removeAttribute("disabled");
        throw "Controlled error !";
     
        return null;
    }
    }
    catch(e) {
        if (e == "Controlled error !") {
            return;
          }
          else {
            console.log("<br />")
            console.log("red: Caught error " )
            console.log("<br />")
            console.log("red: " + e)
            console.log("<br />")
            stopScript = 1;
            botStarted = 0;
            selectbox.removeAttribute("disabled");
            return;
          }
    }
    }

    let verifyStop = async() => {
      // console.log(stopScript);
      if (stopScript == 1) {
        botStarted = 0;
        selectbox.removeAttribute("disabled");
        console.log("<br />")
        console.log("grey: Bot canceled...");
        console.log("<br />")
        throw "Controlled error !";
      }
    }
    
    run();
    
    console.log((`red: Listening for Liquidity Addition to token ${data.to_PURCHASE}`));
  
  };
};

const readValues = () => {
  document.querySelector('.toPurchase').value = getEnvValue('to_PURCHASE');
  document.querySelector('.amountWBNB').value = getEnvValue('AMOUNT_WBNB');
  document.querySelector('.yourAddress').value = getEnvValue('YOUR_ADDRESS');
  document.querySelector('.buySlippage').value = getEnvValue('SLIPPAGE');
  document.querySelector('.sellSlippage').value = getEnvValue('SELL_SLIPPAGE');
  document.querySelector('.gasPrice').value = getEnvValue('GWEI');
  document.querySelector('.gasLimit').value = getEnvValue('GAS_LIMIT');
  document.querySelector('.minLiq').value = getEnvValue('MIN_LIQUIDITY_ADDED');
  document.querySelector('.PrivateKey').value = getEnvValue('YOUR_MNEMONIC');
  document.querySelector('.targetProfit').value = Formatter.percentage(getEnvValue('TARGET_PROFIT'));
};

const writeValues = () => {
  setEnvValue('to_PURCHASE', document.querySelector('.toPurchase').value)
  setEnvValue('AMOUNT_WBNB', document.querySelector('.amountWBNB').value)
  setEnvValue('YOUR_ADDRESS', document.querySelector('.yourAddress').value)
  setEnvValue('SLIPPAGE', document.querySelector('.buySlippage').value)
  setEnvValue('SELL_SLIPPAGE', document.querySelector('.sellSlippage').value)
  setEnvValue('GWEI', document.querySelector('.gasPrice').value)
  setEnvValue('GAS_LIMIT', document.querySelector('.gasLimit').value)
  setEnvValue('MIN_LIQUIDITY_ADDED', document.querySelector('.minLiq').value)
  setEnvValue('YOUR_MNEMONIC', document.querySelector('.PrivateKey').value)

  setEnvValue('TARGET_PROFIT', Formatter.decimal(document.querySelector('.targetProfit').value));

};

const MouseDownInput = () => {
  document.querySelector('.targetProfit').value = document.querySelector('.targetProfit').value.replace('%','');
}

const BlurInput = () => {
  document.querySelector('.targetProfit').value = Formatter.percentage(Formatter.decimal(document.querySelector('.targetProfit').value));
}

const modify = () => {
  readValues();
  document.getElementById("modify").style.backgroundColor = "red";
  document.querySelector('.toPurchase').removeAttribute("readonly");
  document.querySelector('.amountWBNB').removeAttribute("readonly");
  document.querySelector('.yourAddress').removeAttribute("readonly");
  document.querySelector('.buySlippage').removeAttribute("readonly");
  document.querySelector('.sellSlippage').removeAttribute("readonly");
  document.querySelector('.gasPrice').removeAttribute("readonly");
  document.querySelector('.gasLimit').removeAttribute("readonly");
  document.querySelector('.minLiq').removeAttribute("readonly");
  document.querySelector('.targetProfit').removeAttribute("readonly");
  document.querySelector('.PrivateKey').removeAttribute("readonly");

};

const save = () => {
  document.getElementById("modify").style = ".inputBtns:hover {background-color: blue;}";
  document.querySelector('.toPurchase').setAttribute("readonly","readonly");
  document.querySelector('.amountWBNB').setAttribute("readonly","readonly");
  document.querySelector('.yourAddress').setAttribute("readonly","readonly");
  document.querySelector('.buySlippage').setAttribute("readonly","readonly");
  document.querySelector('.sellSlippage').setAttribute("readonly","readonly");
  document.querySelector('.gasPrice').setAttribute("readonly","readonly");
  document.querySelector('.gasLimit').setAttribute("readonly","readonly");
  document.querySelector('.minLiq').setAttribute("readonly","readonly");
  document.querySelector('.targetProfit').setAttribute("readonly","readonly");
  document.querySelector('.PrivateKey').setAttribute("readonly","readonly");

  writeValues();
  readValues();

  msgBox({
    title: 'Benayun Sniper Bot', 
    // buttons: ["OK", "Cancel"], 
    icon: __dirname + '/images/icon.ico',
    message: 'Configuration Parameters', 
    detail: 'Configuration parameters have been modified succesfully!'})

};


